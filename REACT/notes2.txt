=> What is React
    React is a JavaScript library (not a framework) for building user interfaces, mainly for:
        -> Single Page Applications (SPA)
        -> Component-based UIs
        -> Highly interactive web apps
    It was created by Facebook to make UI rendering fast, predictable, and scalable.
    React lets you build UI as components — small, reusable building blocks that manage their own logic and state.

=> Why React is popular
    -> Fast UI updates using Virtual DOM
    -> Component reusability
    -> Huge ecosystem
    -> Declarative UI
    -> Easy to scale large applications

=> What Is the Virtual DOM and How Does It Work? (Document Object Manuipulation)
    The virtual DOM is an in-memory representation of the real DOM elements. Instead of interacting directly with the real DOM, which can be slow and costly 
    in terms of performance, React creates a virtual representation of the UI components. This virtual representation is a lightweight JavaScript object 
    that mirrors the structure of the real DOM.
    -> Here's a step-by-step process of how the virtual DOM works:
    Step 1 – Initial Rendering: when the app starts, the entire UI is represented as a Virtual DOM. React elements are created and rendered into the virtual 
    structure.
    Step 2 – State and Props Changes: as the states and props change in the app, React re-renders the affected components in the virtual DOM. These changes 
    do not immediately impact the real DOM.
    Step 3 – Comparison Using Diff Algorithm: React then uses a diffing algorithm to compare the current version of the Virtual DOM with the previous version. 
    This process identifies the differences (or "diffs") between the two versions.
    Step 4 – Reconciliation Process: based on the differences identified, React determines the most efficient way to update the real DOM. Only the parts of the 
    real DOM that need to be updated are changed, rather than re-rendering the entire UI. This selective updating is quick and performant.
    Step 5 – Update to the Real DOM: finally, React applies the necessary changes to the real DOM. This might involve adding, removing, or updating elements 
    based on the differences detected in step 3.

=> Comparing the Virtual DOM to the Real DOM
    The Real DOM is the browser’s actual representation of the UI, and updating it directly is expensive because every change can trigger reflow and 
    repaint operations, which slow down performance when updates are frequent. The Virtual DOM, used by React, is a lightweight, in-memory JavaScript 
    representation of the Real DOM. When application state or props change, React first updates the Virtual DOM and then compares it with the previous 
    version using a diffing (reconciliation) algorithm. Based on this comparison, React determines the minimum number of changes required and applies only 
    those specific updates to the Real DOM. This approach reduces unnecessary DOM manipulations, improves performance, and makes UI updates more predictable 
    and efficient, especially in large and dynamic applications.

=> What is Shadow DOM?
    Shadow DOM is a term used to describe a limited or restricted view of the DOM tree. Unlike the Virtual DOM, which is a concept used to optimize performance, 
    Shadow DOM refers to a specific structure within the DOM tree itself.

=> difference between stateless and stateful components
    The main difference is that stateful components manage dynamic data and user interactions using an internal state object, while stateless components 
    only receive data via props and render static content without internal memory. 

=> What are props in React?
    In React, props (short for properties) are a mechanism for passing data from a parent component down to a child component. They are essential for making 
    components reusable, dynamic, and configurable. 
    Key Characteristics of Props
    -> Unidirectional Data Flow: Data flows only in one direction: from parent to child.
    -> Read-Only (Immutable): A component cannot modify its own props. If data needs to change, the change must happen in the parent component, which 
    then passes down new props.
    -> Function Arguments: Conceptually, props are the single argument (an object) passed to a component function.
    -> Versatile Data Types: You can pass any JavaScript data type as a prop, including strings, numbers, arrays, objects, and even functions. 

=> Difference between state and props in React?
    In React, props (short for properties) are used to pass data from a parent component to a child component and are immutable (read-only) within the child. 
    State, on the other hand, is used to manage dynamic data within a single component and is mutable (can be changed). 
    Summary Analogy
    Think of a React component as a function. 
    Props are like the function parameters; they are inputs provided by whoever calls the function (the parent component).
    State is like the local variables declared inside the function; it is the component's "memory" that it manages internally and can change over time.

=> Controlled vs Uncontrolled Components in ReactJS
    A controlled component in React is an element whose state is controlled by React itself. This means that the component's state is stored in a React 
    component's state and can only be updated by triggering a state change via React’s setState() method.
    An uncontrolled component in React refers to a component where the form element's state is not directly controlled by React. Instead, the form element 
    itself maintains its own state, and React only interacts with the element indirectly through references (refs).

=> Differences Between Controlled and Uncontrolled Components
    State Management:
    Controlled: Uses React state as the source of truth.
    Uncontrolled: Uses the DOM to maintain internal state.
    Data Flow:
    Controlled: Data flows from React state to input.
    Uncontrolled: Data flows from the input to React only when accessed via refs.
    Validation and Formatting:
    Controlled: Can validate or format input in real-time.
    Uncontrolled: Validation usually occurs on form submission.
    Complexity:
    Controlled: Requires more boilerplate (state and handlers).
    Uncontrolled: Simpler and quicker to implement for basic cases.
    Performance:
    Controlled: May cause more re-renders, as each keystroke updates state.
    Uncontrolled: Potentially better for large forms or infrequent value access.
    Use Cases:
    Controlled: Complex forms, instant feedback, dynamic UI.
    Uncontrolled: Simple forms, legacy code, quick prototypes.

=> What is the purpose of the key attribute in React lists?
    The key attribute in React lists is used to uniquely identify each element in a list so React can efficiently track, update, and re-render items when the list 
    changes. During reconciliation, React uses keys to determine which items have been added, removed, or reordered, allowing it to update only the affected 
    components instead of re-rendering the entire list. This improves performance and prevents bugs such as incorrect state being preserved or reused across 
    list items. Keys should be stable, unique, and consistent (for example, an ID from the data), and using array indexes as keys is discouraged when the list 
    can change dynamically.

=> What are fragments in React?
    Fragments in React are a feature that let you group multiple elements without adding extra nodes to the DOM. Normally, a React component must return a 
    single parent element, but fragments solve this by acting as an invisible wrapper.

=> What are React lifecycle methods?
    React lifecycle methods are special methods that allow you to run code at specific stages of a component’s life, from creation to removal. In class 
    components, the lifecycle is divided into three main phases: mounting, updating, and unmounting. During mounting, methods like constructor() and 
    componentDidMount() are used to initialize state and perform side effects such as API calls. In the updating phase, methods like shouldComponentUpdate(), 
    componentDidUpdate(), and getDerivedStateFromProps() help control and respond to re-renders when props or state change. Finally, during unmounting, 
    componentWillUnmount() is used for cleanup tasks such as removing event listeners or canceling subscriptions. In modern React, Hooks (especially useEffect) 
    are preferred in functional components, as they provide the same lifecycle behavior in a simpler and more unified way.

=> Explain the useState and useEffect hooks.
    useState and useEffect are fundamental React Hooks used in functional components to manage state and side effects.
    The useState hook allows a component to store and update local state. It returns a state variable and a function to update it. When the state changes, 
    React re-renders the component to reflect the new data. This makes components dynamic and interactive, such as updating counters, form inputs, or toggling 
    UI elements.
    The useEffect hook is used to handle side effects in a component, such as data fetching, subscriptions, timers, or manually interacting with the DOM. 
    It runs after the component renders and can be controlled using a dependency array. With no dependency array, it runs after every render; with an empty 
    array, it runs only once when the component mounts; and with specific dependencies, it runs only when those values change. It can also return a cleanup 
    function to handle tasks like removing event listeners or canceling API requests when the component unmounts or before re-running the effect.

=> What is props drilling in React? and how to avoid it
    Props drilling in React refers to the situation where data is passed from a parent component to deeply nested child components through multiple intermediate 
    components, even though those intermediate components do not actually need the data themselves. This makes the code harder to read, maintain, and refactor, 
    and tightly couples components that should otherwise remain independent.
    To avoid props drilling, React provides several approaches. The most common solution is the Context API, which allows data to be stored at a higher level and 
    accessed directly by any descendant component without passing props through every level. Another approach is using state management libraries like Redux, 
    Zustand, or Recoil, which centralize shared state and make it accessible across the application. For simpler cases, component composition (passing components 
    as children) can also reduce unnecessary prop passing. In larger applications, lifting shared logic into custom hooks or using global state patterns 
    helps keep components clean and scalable.

=> What is the Context API?
    The Context API in React is a built-in feature used to share data globally across components without passing props manually at every level (avoiding 
    props drilling). It allows you to create a context, provide a value at a higher level in the component tree, and consume that value in any descendant 
    component that needs it.
    Context is commonly used for theme settings, authentication data, user information, language preferences, or global configuration. It works by wrapping 
    components with a Provider, which holds the shared state, and accessing that state using the Consumer or the useContext hook in functional components. 
    While Context simplifies state sharing, it should be used thoughtfully, as frequent updates to context values can trigger re-renders in all consuming 
    components.

=>  What are HOCs? 
    Higher-Order Components (HOCs) in React are a pattern for reusing component logic. An HOC is a function that takes a component as input and returns a 
    new enhanced component with additional props or behavior, without modifying the original component.
    HOCs are commonly used for cross-cutting concerns such as authentication, authorization, logging, error handling, or data fetching. They help keep 
    components focused on UI while shared logic is abstracted into reusable wrappers. Since HOCs wrap components, they can sometimes make component hierarchies 
    harder to follow, which is why modern React often prefers Hooks for logic reuse—but HOCs are still important to understand, especially in legacy codebases.

=>  Reconciliation in React.
    Reconciliation in React is the process by which React updates the UI efficiently when state or props change. Instead of re-rendering the entire DOM, React 
    creates a new Virtual DOM tree and compares it with the previous one. This comparison process, called diffing, helps React identify exactly what has 
    changed. Based on this analysis, React calculates the minimum number of updates required and applies only those changes to the Real DOM. Reconciliation 
    relies on assumptions such as elements of different types producing different trees and the use of key attributes to efficiently track list items. This 
    mechanism is what allows React applications to remain fast, predictable, and scalable even as the UI becomes complex.

=> How does React Router handle navigation in a single-page app?
    React Router handles navigation in a single-page application (SPA) by updating the URL and rendered components without triggering a full page reload. It 
    uses the browser’s History API (pushState, replaceState, and popstate) to keep the URL in sync with the UI. When a user navigates using components like 
    <Link> or <NavLink>, React Router intercepts the click, updates the browser history, and renders the matching component defined in <Routes>—all while 
    staying on the same HTML page.
    Because the app never reloads, React Router enables fast transitions, state preservation, and a native app-like experience. It also supports dynamic 
    routes, nested routes, route parameters, and lazy loading, allowing developers to structure complex navigation logic cleanly while maintaining SPA 
    performance.

=> Explain React strict mode.
    React Strict Mode is a development-only tool that helps developers identify potential problems and unsafe practices in a React application. It does not 
    affect the production build or the actual UI rendered to users. Instead, it adds extra checks and warnings during development to encourage writing 
    future-proof and reliable code.
    When enabled using <React.StrictMode>, React intentionally invokes certain lifecycle methods, render phases, and effects twice (in development only). 
    This helps detect side effects, unintended mutations, and code that relies on deprecated APIs or improper cleanup logic. Strict Mode also highlights 
    issues like usage of legacy lifecycle methods, unsafe side effects inside render, and problems with reusable state logic.

=> 